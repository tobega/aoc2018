composer nanobot
  { (<'pos=<'>) x: <INT>, (<','>) y: <INT>, (<','>) z: <INT>, (<'>, r='>) range: <INT> }
end nanobot

def bots: [ $IN::lines -> nanobot ]

templates abs
  <0..> $it ! <> -$it !
end abs

templates reduce@{op:}
  @: $it(1)
  $it(2..-1)... -> (@reduce: [$@reduce, $it] -> op) -> void
  $@ !
end reduce

// part1
templates manhattanDistance@{from:}
  (($it.x - $from.x) -> abs) + (($it.y - $from.y) -> abs) + (($it.z - $from.z) -> abs) !
end manhattanDistance

templates biggestRange
  <?($it(1).range <$it(2).range..>)> $it(1) ! <> $it(2) !
end biggestRange

def biggest: $bots -> reduce@{op:biggestRange}

[ $bots... -> manhattanDistance@{from:$biggest} -> (<..$biggest.range> $it !) ] -> $it::length -> !OUT::write

'
' -> !OUT::write

// part2
// Resolving the planes defining the octahedron gives a nice set of equations
// 1: x + y + z <= r + a + b + c
// 2: x + y - z <= r + a + b - c
// 3: x - y + z <= r + a - b + c
// 4: x - y - z <= r + a - b - c
// 5: - x + y + z <= r - a + b + c
// 6: - x + y - z <= r - a + b - c
// 7: - x - y + z <= r - a - b + c
// 8: - x - y - z <= r - a - b - c

templates isFeasible
  @: 1
  def bot: $it
  1..4 -> (<?($bot.constraints($it) + $bot.constraints(-$it) <..~0>)> @isFeasible: 0) -> void
  $@ !
end isFeasible

templates octahedronAround
  { intersectingBots: 1, constraints: [
    $it.range + $it.x + $it.y + $it.z,
    $it.range + $it.x + $it.y - $it.z,
    $it.range + $it.x - $it.y + $it.z,
    $it.range + $it.x - $it.y - $it.z,
    $it.range - $it.x + $it.y + $it.z,
    $it.range - $it.x + $it.y - $it.z,
    $it.range - $it.x - $it.y + $it.z,
    $it.range - $it.x - $it.y - $it.z
  ]} !
end octahedronAround

templates min
  <?($it(1) <..$it(2)>)> $it(1) ! <> $it(2) !
end min

templates transpose
  def a: $it
  [1..$a(1)::length -> $a(1..-1;$it)] !
end transpose

templates intersect
  { intersectingBots: $it(1).intersectingBots + $it(2).intersectingBots,
    constraints: [[$it(1).constraints, $it(2).constraints] -> transpose ... -> min] } !
end intersect

templates part2
  def empty: { intersectingBots: 0, constraints: [1..8 -> 999999999]}
  @: { largestIntersect: $empty,
    feasibleChoices: $it, remainingFeasibleChoices: [[]], currentIntersects: [ $empty ]}
  $@ -> #

  <{feasibleChoices: <[](1..)>}
      ?($it.currentIntersects(-1).intersectingBots + $it.feasibleChoices::length
        <$it.largestIntersect.intersectingBots~..>)>
    def currentIntersect: [$it.currentIntersects(-1), $it.feasibleChoices(1)] -> intersect
    ..|@.currentIntersects: $currentIntersect
    def largestIntersect: $it.largestIntersect -> (<{ intersectingBots: <..$currentIntersect.intersectingBots>}> $currentIntersect ! <> $it !)
    ..|@.remainingFeasibleChoices: $it.feasibleChoices(2..-1)
    ..|@: { feasibleChoices: [ $it.feasibleChoices(2..-1)... -> [$it, $currentIntersect] -> intersect -> (<?($it -> isFeasible <1>)> $it !) ],
      largestIntersect: $largestIntersect}
    $@ -> #

  <{remainingFeasibleChoices: <[](1..)>}>
    ..|@: { currentIntersects: $it.currentIntersects(1..-2),
      feasibleChoices: $it.remainingFeasibleChoices(-1),
      remainingFeasibleChoices: $it.remainingFeasibleChoices(1..-2) }
    $@ -> #

  <>
  // Shaky hypothesis: turning the octahedron equations to >= means that the
  // minimum must be when it is =. But manhattan distance is the sum of absolute
  // values, so it must be the maximum of all the octahedron >= bounds.
    0 - ($it.largestIntersect.constraints -> reduce@{op:min}) !
end part2

templates byBiggestRange
  $it(2).range - $it(1).range !
end byBiggestRange

templates sort@{comp:}
  @: []
  $it -> #
  <[](2..)>
    def pivot: $it(1)
    [ [ $it(2..-1)... -> (
      <?([$it, $pivot] -> $comp <..0>)>
        $it !
      <>
        ..|@sort: $it
     )] -> sort@{comp:comp}..., $pivot, $@ -> sort@{comp:comp}... ] !
   <>
     $it !
end sort

def cubes: [ $bots -> sort@{comp:byBiggestRange} ... -> octahedronAround ]

$cubes -> part2 -> !OUT::write
