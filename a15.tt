def input: [ $IN::lines -> [ $it... ] ]

templates flatten
  [ $it -> # ] !
  <[]> $it... -> #
  <> $it !
end flatten

templates sum
  @: $it(1)
  $it(2..-1)... -> #
  $@ !
  <>
    @: $it + $@
end sum

templates bestPosition
  <[] ?($it(1).row <$it(2).row~..>)>
    1 !

  <[] ?($it(1).row <..~$it(2).row>)>
    -1 !

  <[] ?($it(1).col <$it(2).col~..>)>
    1 !

  <>
    -1 !
end bestPosition

templates first@{comp:}
  @: $it(1)
  $it(2..-1)... -> #
  $@!
  <?([$it, $@] -> comp <..~0>)> @: $it
end first

templates lowest@{comp:}
  @: [$it(1)]
  $it(2..-1)... -> #
  $@!
  <?([$it, $@(1)] -> comp <0>)> ..|@: $it
  <?([$it, $@(1)] -> comp <..~0>)> @: [$it]
end lowest

templates sort@{comp:}
  @: []
  $it -> #
  <[](2..)>
    def pivot: $it(1)
    [ [ $it(2..-1)... -> (
      <?([$it, $pivot] -> $comp <..0>)>
        $it !
      <>
        ..|@sort: $it
     )] -> sort@{comp:comp}..., $pivot, $@ -> sort@{comp:comp}... ] !
   <>
     $it !
end sort

processor Battleground
  @: $it -> [i,j]({ contains: $it, row: $i, col: $j } !)

  templates remove
    def pos: $it
    @Battleground($pos.row; $pos.col).contains: '.'
  end remove

  templates neighbours
    $@Battleground($it.row; [$it.col-1, $it.col+1])... !
    $@Battleground([$it.row-1, $it.row+1]; $it.col)... !
  end neighbours

  templates inRange@{target:}
    @: 0
    $it -> neighbours
      -> (<{contains:<$target>}> @inRange: 1) -> void
    $@ !
  end inRange

  templates bestSquareInRange@{target:}
    @: []
    $it... -> #
    $@ -> (<[](1..)> $it!) -> first@{comp:bestPosition} !

    <?($it -> inRange@{target:$target} <1>)>
      ..|@: $it
  end bestSquareInRange

  templates findDirectionToMove@{target:}
      templates moveEntry@{firstMove:}
        <{contains:<'\.'>}>
          { $it..., move: $firstMove } !
      end moveEntry

      templates nextMoves
        def move: $it.move
        $it -> neighbours -> moveEntry@{firstMove:$move} !
      end nextMoves
    templates prioritizedDirection
      <{a:<'up'>}|{b:<'up'>}>
        'up'!

      <{a:<'left'>}|{b:<'left'>}>
        'left'!

      <{a:<'right'>}|{b:<'right'>}>
       'right'!

      <{a:<'down'>}|{b:<'down'>}>
        'down'!
    end prioritizedDirection

    def combattant: $it
    @: {visited: $@Battleground,
        atDistance: [
            $@Battleground($combattant.row - 1; $combattant.col) -> moveEntry@{firstMove: 'up'},
            $@Battleground($combattant.row; $combattant.col - 1) -> moveEntry@{firstMove: 'left'},
            $@Battleground($combattant.row; $combattant.col + 1) -> moveEntry@{firstMove: 'right'},
            $@Battleground($combattant.row + 1; $combattant.col) -> moveEntry@{firstMove: 'down'}
        ]
    }
    [$@.atDistance -> bestSquareInRange@{target:$target}] -> #

    <[](1..)>
      $it(1).move !

    <?($@.atDistance <[](1..)>)>
      $@.atDistance... -> (..|@findDirectionToMove.visited($it.row;$it.col): $it -> {row: $it.row, col: $it.col, contains: 'visited'}
        ) -> void
      def next: [$@.atDistance... -> nextMoves
        -> (<?($@findDirectionToMove.visited($it.row;$it.col) <{contains:<'\.'>}>)> $it !)
      ]
      $next... -> (..|@findDirectionToMove.visited($it.row;$it.col): {move: 'any'}) -> void
      $next... -> (@findDirectionToMove.visited($it.row;$it.col).move:
        {a: $it.move, b: $@findDirectionToMove.visited($it.row;$it.col).move}  -> prioritizedDirection
      ) -> void
      @.atDistance: [ $next... -> (<?($it.move <$@findDirectionToMove.visited($it.row;$it.col).move>)> $it !)]
      [$@.atDistance -> bestSquareInRange@{target:$target}] -> #
  end findDirectionToMove

  templates maybeMove@{target:}
    @: $it
    $it -> inRange@{target:$target} -> (<0> $@maybeMove !) -> findDirectionToMove@{target:$target} -> #

    <'up'>
      {dr:-1, dc:0} -> #

    <'left'>
      {dr:0, dc:-1} -> #

    <'right'>
      {dr:0, dc:1} -> #

    <'down'>
      {dr:1, dc:0} -> #

    <{dr:<>,dc:<>}>
      def move: $it
      ..|@Battleground($@.row; $@.col): {contains:'.'}
      ..|@Battleground($@.row + $move.dr; $@.col + $move.dc): {contains: $@.type}
      $@Battleground($@.row + $move.dr; $@.col + $move.dc) !
  end maybeMove
end Battleground

processor Battle@{setCombatValues:, isFightDecided:}
  @: { battleground: $it -> Battleground,
    lastBeingStruck: 0, // if last being struck, another round was completed
    beings: [ $it -> [i,j](<'G'|'E'> { type: $it, row: $i, col: $j } !)
      -> flatten -> [i]({$it..., index: $i} !) ... -> setCombatValues] }

  templates liveBeingAtPosition
    def col:$it.col
    def row: $it.row
    $@Battle.beings... -> (<{col:<$col>, row:<$row>, hitPoints: <1..>}> $it !) !
  end liveBeingAtPosition

  // should be sink
  templates strike@{damage:}
    @Battle.lastBeingStruck: 1
    def pos: $it
    def index: $it.index
    @Battle.beings($index).hitPoints: ($@Battle.beings($index).hitPoints - $damage)
    $@Battle.beings($index).hitPoints -> (<..0> $pos!) -> $@Battle.battleground::remove -> void
  end strike

  templates enemyType
    <'G'> 'E' !
    <'E'> 'G' !
  end enemyType

  templates adjacentEnemy@{me:}
    def enemy: $me -> enemyType
    $it -> $@Battle.battleground::neighbours
      -> (<{contains:<$enemy>}> $it !) !
  end adjacentEnemy

  // should be sink
  templates takeTurn
    def who: $it.index
    def enemy: $it.type -> enemyType
    $@Battle.beings($who) -> #

    <{hitPoints:<1..>}>
    @Battle.lastBeingStruck: 0
    templates lowPoints
      <?($it(1).hitPoints <$it(2).hitPoints>)> 0 !
      <?($it(1).hitPoints <..$it(2).hitPoints>)> -1 !
      <> 1 !
    end lowPoints
    ..|@Battle.beings($who): $it -> $@Battle.battleground::maybeMove@{target:$enemy}
      -> { row: $it.row, col: $it.col}
    [ $@Battle.beings($who) -> adjacentEnemy@{me: $@Battle.beings($who).type} -> liveBeingAtPosition
    ] -> (<[](1..)> $it!) -> lowest@{comp:lowPoints} -> first@{comp: bestPosition} -> strike@{damage: $@Battle.beings($who).attackValue}
      -> void
  end takeTurn

  // should be source
  templates run
    @: {round: -1, isDone: 0}
    $@ -> #

    <{isDone: <0>}>
      @.round: $@.round + 1
      $@Battle.beings -> sort@{comp: bestPosition}...
        -> (<{hitPoints: <1..>}> $it !)
        -> takeTurn -> void
      @.isDone: $@Battle.beings -> isFightDecided
      $@ -> #

    <>
      [ $@Battle.beings... -> (<{hitPoints: <1..>}> $it.hitPoints !) ] -> sum ->  $@.isDone * ($@.round + $@Battle.lastBeingStruck) * $it !
  end run
end Battle

// part 1

  templates basicCombatValues
    {$it..., attackValue: 3, hitPoints: 200} !
  end basicCombatValues

  templates oneRaceStanding
    @: {elfAlive: 0, goblinAlive: 0}
    $it... -> #
    $@ -> (<{goblinAlive: <1>, elfAlive: <1>}> 0! <> 1!) !

    <{type: <'G'>, hitPoints: <1..>}>
      ..|@: {goblinAlive: 1}

    <{type: <'E'>, hitPoints: <1..>}>
      ..|@: {elfAlive: 1}
  end oneRaceStanding

def battle: $input -> Battle@{setCombatValues:basicCombatValues, isFightDecided:oneRaceStanding}
'$battle::run;
'-> !OUT::write

// part 2
templates victoryOrDeath
    @: {elfDied: 0, goblinAlive: 0}
    $it... -> #
    $@ -> (<{elfDied: <1>}> -1 ! <{goblinAlive: <1>}> 0 ! <> 1 !) !

    <{type: <'G'>, hitPoints: <1..>}>
      ..|@: {goblinAlive: 1}

    <{type: <'E'>, hitPoints: <..0>}>
      ..|@: {elfDied: 1}
end victoryOrDeath

  templates tweakedCombatValues@{elfAttack:}
    <{type: <'G'>}>
      {$it..., attackValue: 3, hitPoints: 200} !

    <{type: <'E'>}>
      {$it..., attackValue: $elfAttack, hitPoints: 200} !
  end tweakedCombatValues

// should be source
templates part2
  @: { elfAttack: 3, result: -1 }
  $@ -> #

  <{result: <..~0>}>
    ..|@: { elfAttack: $@.elfAttack + 1 }
    def battle: $input -> Battle@{setCombatValues:tweakedCombatValues@{elfAttack: $@.elfAttack}, isFightDecided:victoryOrDeath}
    ..|@: { result: $battle::run}
    $@ -> #

  <{result: <0..>}>
    $@ -> !OUT::write
end part2

0 -> part2 -> !OUT::write
