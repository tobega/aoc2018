def input: [ stdin -> [ $it... ] ]

templates flatten
  [ $it -> # ] !
  <[]> $it... -> #
  <> $it !
end flatten

templates sum
  $it(1) -> @
  $it(2..-1)... -> #
  $@ !
  <>
    $it + $@ -> @
end sum

templates bestPosition
  <[] ?($it(1).row <$it(2).row~..>)>
    1 !

  <[] ?($it(1).row <..~$it(2).row>)>
    -1 !

  <[] ?($it(1).col <$it(2).col~..>)>
    1 !

  <>
    -1 !
end bestPosition

templates first@{comp:}
  $it(1) -> @
  $it(2..-1)... -> #
  $@!
  <?([$it, $@] -> comp <..~0>)> $it -> @
end first

templates lowest@{comp:}
  [$it(1)] -> @
  $it(2..-1)... -> #
  $@!
  <?([$it, $@(1)] -> comp <0>)> $it -> ...@
  <?([$it, $@(1)] -> comp <..~0>)> [$it] -> @
end lowest

templates sort@{comp:}
  [] -> @
  $it -> #
  <[](2..)>
    def pivot: $it(1)
    [ [ $it(2..-1)... -> (
      <?([$it, $pivot] -> $comp <..0>)>
        $it !
      <>
        $it -> ...@sort
     )] -> sort@{comp:comp}..., $pivot, $@ -> sort@{comp:comp}... ] !
   <>
     $it !
end sort

processor Battleground
  $it -> [i,j]({ contains: $it, row: $i, col: $j } !) -> @

  templates remove
    def pos: $it
    '.' -> @Battleground($pos.row; $pos.col).contains
  end remove

  templates neighbours
    $@Battleground($it.row; [$it.col-1, $it.col+1])... !
    $@Battleground([$it.row-1, $it.row+1]; $it.col)... !
  end neighbours

  templates inRange@{target:}
    0 -> @
    $it -> neighbours
      -> (<{contains:<$target>}> 1 -> @inRange) -> void
    $@ !
  end inRange

  templates bestSquareInRange@{target:}
    [] -> @
    $it... -> #
    $@ -> (<[](1..)> $it!) -> first@{comp:bestPosition} !

    <?($it -> inRange@{target:$target} <1>)>
      $it -> ...@
  end bestSquareInRange

  templates findDirectionToMove@{target:}
      templates moveEntry@{firstMove:}
        <{contains:<'\.'>}>
          { $it..., move: $firstMove } !
      end moveEntry

      templates nextMoves
        def move: $it.move
        $it -> neighbours -> moveEntry@{firstMove:$move} !
      end nextMoves
    templates prioritizedDirection
      <{a:<'up'>}|{b:<'up'>}>
        'up'!

      <{a:<'left'>}|{b:<'left'>}>
        'left'!

      <{a:<'right'>}|{b:<'right'>}>
       'right'!

      <{a:<'down'>}|{b:<'down'>}>
        'down'!
    end prioritizedDirection

    def combattant: $it
    {visited: $@Battleground,
        atDistance: [
            $@Battleground($combattant.row - 1; $combattant.col) -> moveEntry@{firstMove: 'up'},
            $@Battleground($combattant.row; $combattant.col - 1) -> moveEntry@{firstMove: 'left'},
            $@Battleground($combattant.row; $combattant.col + 1) -> moveEntry@{firstMove: 'right'},
            $@Battleground($combattant.row + 1; $combattant.col) -> moveEntry@{firstMove: 'down'}
        ]
    } -> @
    [$@.atDistance -> bestSquareInRange@{target:$target}] -> #

    <[](1..)>
      $it(1).move !

    <?($@.atDistance <[](1..)>)>
      $@.atDistance... -> ($it -> {row: $it.row, col: $it.col, contains: 'visited'}
        -> ...@findDirectionToMove.visited($it.row;$it.col)) -> void
      def next: [$@.atDistance... -> nextMoves
        -> (<?($@findDirectionToMove.visited($it.row;$it.col) <{contains:<'\.'>}>)> $it !)
      ]
      $next... -> (def this: $it
        {move: 'any'} -> ...@findDirectionToMove.visited($this.row;$this.col)) -> void
      $next... -> (def this: $it
         {a: $it.move, b: $@findDirectionToMove.visited($it.row;$it.col).move}  -> prioritizedDirection
           -> @findDirectionToMove.visited($this.row;$this.col).move) -> void
      [ $next... -> (<?($it.move <$@findDirectionToMove.visited($it.row;$it.col).move>)> $it !)
      ] -> @.atDistance
      [$@.atDistance -> bestSquareInRange@{target:$target}] -> #
  end findDirectionToMove

  templates maybeMove@{target:}
    $it -> @
    $it -> inRange@{target:$target} -> (<0> $@maybeMove !) -> findDirectionToMove@{target:$target} -> #

    <'up'>
      {dr:-1, dc:0} -> #

    <'left'>
      {dr:0, dc:-1} -> #

    <'right'>
      {dr:0, dc:1} -> #

    <'down'>
      {dr:1, dc:0} -> #

    <{dr:<>,dc:<>}>
      def move: $it
      {contains:'.'} -> ...@Battleground($@.row; $@.col)
      {contains: $@.type} -> ...@Battleground($@.row + $move.dr; $@.col + $move.dc)
      $@Battleground($@.row + $move.dr; $@.col + $move.dc) !
  end maybeMove
end Battleground

processor Battle@{setCombatValues:, isFightDecided:}
  { battleground: $it -> Battleground,
    beings: [ $it -> [i,j](<'G'|'E'> { type: $it, row: $i, col: $j } !)
      -> flatten -> [i]({$it..., index: $i} !) ... -> setCombatValues] } -> @

  templates liveBeingAtPosition
    def col:$it.col
    def row: $it.row
    $@Battle.beings... -> (<{col:<$col>, row:<$row>, hitPoints: <1..>}> $it !) !
  end liveBeingAtPosition

  // should be sink
  templates strike@{damage:}
    def pos: $it
    def index: $it.index
    ($@Battle.beings($index).hitPoints - $damage) -> @Battle.beings($index).hitPoints
    $@Battle.beings($index).hitPoints -> (<..0> $pos!) -> $@Battle.battleground::remove -> void
  end strike

  templates enemyType
    <'G'> 'E' !
    <'E'> 'G' !
  end enemyType

  templates adjacentEnemy@{me:}
    def enemy: $me -> enemyType
    $it -> $@Battle.battleground::neighbours
      -> (<{contains:<$enemy>}> $it !) !
  end adjacentEnemy

  // should be sink
  templates takeTurn
    def who: $it.index
    def enemy: $it.type -> enemyType
    $@Battle.beings($who) -> #

    <{hitPoints:<1..>}>
    templates lowPoints
      <?($it(1).hitPoints <$it(2).hitPoints>)> 0 !
      <?($it(1).hitPoints <..$it(2).hitPoints>)> -1 !
      <> 1 !
    end lowPoints
    $it -> $@Battle.battleground::maybeMove@{target:$enemy}
      -> { row: $it.row, col: $it.col} -> ...@Battle.beings($who)
    [ $@Battle.beings($who) -> adjacentEnemy@{me: $@Battle.beings($who).type} -> liveBeingAtPosition
    ] -> (<[](1..)> $it!) -> lowest@{comp:lowPoints} -> first@{comp: bestPosition} -> strike@{damage: $@Battle.beings($who).attackValue}
      -> void
  end takeTurn

  // should be source
  templates run
    {round: -1, isDone: 0} -> @
    $@ -> #

    <{isDone: <0>}>
      $@.round + 1 -> @.round
      $@Battle.beings -> sort@{comp: bestPosition}...
        -> (<{hitPoints: <1..>}> $it !)
        -> takeTurn -> void
      $@Battle.beings -> isFightDecided -> @.isDone
      $@ -> #

    <>
      [ $@Battle.beings... -> (<{hitPoints: <1..>}> $it.hitPoints !) ] -> sum ->  $@.isDone * $@.round * $it !
  end run
end Battle

// part 1

  templates basicCombatValues
    {$it..., attackValue: 3, hitPoints: 200} !
  end basicCombatValues

  templates oneRaceStanding
    {elfAlive: 0, goblinAlive: 0} -> @
    $it... -> #
    $@ -> (<{goblinAlive: <1>, elfAlive: <1>}> 0! <> 1!) !

    <{type: <'G'>, hitPoints: <1..>}>
      {goblinAlive: 1} -> ...@

    <{type: <'E'>, hitPoints: <1..>}>
      {elfAlive: 1} -> ...@
  end oneRaceStanding

def battle: $input -> Battle@{setCombatValues:basicCombatValues, isFightDecided:oneRaceStanding}
'$battle::run;
'-> stdout

// part 2
templates victoryOrDeath
    {elfDied: 0, goblinAlive: 0} -> @
    $it... -> #
    $@ -> (<{elfDied: <1>}> -1 ! <{goblinAlive: <1>}> 0 ! <> 1 !) !

    <{type: <'G'>, hitPoints: <1..>}>
      {goblinAlive: 1} -> ...@

    <{type: <'E'>, hitPoints: <..0>}>
      {elfDied: 1} -> ...@
end victoryOrDeath

  templates tweakedCombatValues@{elfAttack:}
    <{type: <'G'>}>
      {$it..., attackValue: 3, hitPoints: 200} !

    <{type: <'E'>}>
      {$it..., attackValue: $elfAttack, hitPoints: 200} !
  end tweakedCombatValues

// should be source
templates part2
  { elfAttack: 3, result: -1 } -> @
  $@ -> #

  <{result: <..~0>}>
    { elfAttack: $@.elfAttack + 1 } -> ...@
    def battle: $input -> Battle@{setCombatValues:tweakedCombatValues@{elfAttack: $@.elfAttack}, isFightDecided:victoryOrDeath}
    { result: $battle::run} -> ...@
    $@ -> #

  <{result: <0..>}>
    $@ -> stdout
end part2

0 -> part2 -> stdout
// Almost correct, we get one too few rounds (presumably when the last elf in a round kills the final goblin)