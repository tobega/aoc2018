def input: [ $IN::lines -> [ $... ] ];

templates flatten
  [ $ -> # ] !
  <[]> $... -> #
  <> $ !
end flatten

templates sum
  @: $(1);
  $(2..-1)... -> @: $ + $@;
  $@ !
end sum

templates bestPosition
  <[] ?($(1).row <$(2).row~..>)>
    1 !

  <[] ?($(1).row <..~$(2).row>)>
    -1 !

  <[] ?($(1).col <$(2).col~..>)>
    1 !

  <>
    -1 !
end bestPosition

templates first@{comp:}
  @: $(1);
  $(2..-1)... -> #
  $@!
  <?([$, $@] -> comp <..~0>)> @: $;
end first

templates lowest@{comp:}
  @: [$(1)];
  $(2..-1)... -> #
  $@!
  <?([$, $@(1)] -> comp <0>)> ..|@: $;
  <?([$, $@(1)] -> comp <..~0>)> @: [$];
end lowest

templates sort@{comp:}
  @: [];
  $ -> #
  <[](2..)>
    def pivot: $(1);
    [ [ $(2..-1)... -> (
      <?([$, $pivot] -> comp <..0>)>
        $ !
      <>
        ..|@sort: $;
     )] -> sort@{comp:comp}..., $pivot, $@ -> sort@{comp:comp}... ] !
   <>
     $ !
end sort

processor Battleground
  @: $ -> [i,j]({ contains: $, row: $i, col: $j } !);

  sink remove
    def pos: $;
    @Battleground($pos.row; $pos.col).contains: '.';
  end remove

  templates neighbours
    $@Battleground($.row; [$.col-1, $.col+1])... !
    $@Battleground([$.row-1, $.row+1]; $.col)... !
  end neighbours

  templates inRange@{target:}
    @: 0;
    $ -> neighbours
      -> (<{contains:<$target>}> @inRange: 1;) -> !VOID
    $@ !
  end inRange

  templates bestSquareInRange@{target:}
    @: [];
    $... -> #
    $@ -> (<[](1..)> $!) -> first@{comp:bestPosition} !

    <?($ -> inRange@{target:$target} <1>)>
      ..|@: $;
  end bestSquareInRange

  templates findDirectionToMove@{target:}
      templates moveEntry@{firstMove:}
        <{contains:<'\.'>}>
          { $..., move: $firstMove } !
      end moveEntry

      templates nextMoves
        def move: $.move;
        $ -> neighbours -> moveEntry@{firstMove:$move} !
      end nextMoves

      templates prioritizedDirection
        <{a:<'up'>}|{b:<'up'>}>
          'up'!

        <{a:<'left'>}|{b:<'left'>}>
          'left'!

        <{a:<'right'>}|{b:<'right'>}>
         'right'!

        <{a:<'down'>}|{b:<'down'>}>
          'down'!
      end prioritizedDirection

    def combattant: $;
    @: {visited: $@Battleground,
        atDistance: [
            $@Battleground($combattant.row - 1; $combattant.col) -> moveEntry@{firstMove: 'up'},
            $@Battleground($combattant.row; $combattant.col - 1) -> moveEntry@{firstMove: 'left'},
            $@Battleground($combattant.row; $combattant.col + 1) -> moveEntry@{firstMove: 'right'},
            $@Battleground($combattant.row + 1; $combattant.col) -> moveEntry@{firstMove: 'down'}
        ]
    };
    [$@.atDistance -> bestSquareInRange@{target:$target}] -> #

    <[](1..)>
      $(1).move !

    <?($@.atDistance <[](1..)>)>
      $@.atDistance... -> ..|@findDirectionToMove.visited($.row;$.col): $ -> {row: $.row, col: $.col, contains: 'visited'};
      def next: [$@.atDistance... -> nextMoves
        -> (<?($@findDirectionToMove.visited($.row;$.col) <{contains:<'\.'>}>)> $ !)
      ];
      $next... -> ..|@findDirectionToMove.visited($.row;$.col): {move: 'any'};
      $next... -> @findDirectionToMove.visited($.row;$.col).move:
        {a: $.move, b: $@findDirectionToMove.visited($.row;$.col).move}  -> prioritizedDirection;
      @.atDistance: [ $next... -> (<?($.move <$@findDirectionToMove.visited($.row;$.col).move>)> $ !)];
      [$@.atDistance -> bestSquareInRange@{target:$target}] -> #
  end findDirectionToMove

  templates maybeMove@{target:}
    @: $;
    $ -> inRange@{target:$target} -> (<0> $@maybeMove !) -> findDirectionToMove@{target:$target} -> #

    <'up'>
      {dr:-1, dc:0} -> #

    <'left'>
      {dr:0, dc:-1} -> #

    <'right'>
      {dr:0, dc:1} -> #

    <'down'>
      {dr:1, dc:0} -> #

    <{dr:<>,dc:<>}>
      def move: $;
      ..|@Battleground($@.row; $@.col): {contains:'.'};
      ..|@Battleground($@.row + $move.dr; $@.col + $move.dc): {contains: $@.type};
      $@Battleground($@.row + $move.dr; $@.col + $move.dc) !
  end maybeMove
end Battleground

processor Battle@{setCombatValues:, isFightDecided:}
  @: { battleground: $ -> Battleground,
    lastBeingStruck: 0, // if last being struck, another round was completed
    beings: [ $ -> [i,j](<'G'|'E'> { type: $, row: $i, col: $j } !)
      -> flatten -> [i]({$..., index: $i} !) ... -> setCombatValues] };

  templates liveBeingAtPosition
    def col:$.col;
    def row: $.row;
    $@Battle.beings... -> (<{col:<$col>, row:<$row>, hitPoints: <1..>}> $ !) !
  end liveBeingAtPosition

  sink strike@{damage:}
    @Battle.lastBeingStruck: 1;
    def pos: $;
    def index: $.index;
    @Battle.beings($index).hitPoints: ($@Battle.beings($index).hitPoints - $damage);
    $@Battle.beings($index).hitPoints -> (<..0> $pos!) -> !@Battle.battleground::remove
  end strike

  templates enemyType
    <'G'> 'E' !
    <'E'> 'G' !
  end enemyType

  templates adjacentEnemy@{me:}
    def enemy: $me -> enemyType;
    $ -> @Battle.battleground::neighbours
      -> (<{contains:<$enemy>}> $ !) !
  end adjacentEnemy

  sink takeTurn
    def who: $.index;
    def enemy: $.type -> enemyType;
    $@Battle.beings($who) -> #

    <{hitPoints:<1..>}>
    @Battle.lastBeingStruck: 0;
    templates lowPoints
      <?($(1).hitPoints <$(2).hitPoints>)> 0 !
      <?($(1).hitPoints <..$(2).hitPoints>)> -1 !
      <> 1 !
    end lowPoints
    $ -> @Battle.battleground::maybeMove@{target:$enemy}
          -> ..|@Battle.beings($who): { row: $.row, col: $.col};
    [ $@Battle.beings($who) -> adjacentEnemy@{me: $@Battle.beings($who).type} -> liveBeingAtPosition
    ] -> (<[](1..)> $!) -> lowest@{comp:lowPoints} -> first@{comp: bestPosition} -> !strike@{damage: $@Battle.beings($who).attackValue}
  end takeTurn

  source run
    @: {round: -1, isDone: 0};
    $@ -> #

    <{isDone: <0>}>
      @.round: $@.round + 1;
      $@Battle.beings -> sort@{comp: bestPosition}...
        -> (<{hitPoints: <1..>}> $ !)
        -> !takeTurn
      @.isDone: $@Battle.beings -> isFightDecided;
      $@ -> #

    <>
      [ $@Battle.beings... -> (<{hitPoints: <1..>}> $.hitPoints !) ] -> sum ->  $@.isDone * ($@.round + $@Battle.lastBeingStruck) * $ !
  end run
end Battle

// part 1

  templates basicCombatValues
    {$..., attackValue: 3, hitPoints: 200} !
  end basicCombatValues

  templates oneRaceStanding
    @: {elfAlive: 0, goblinAlive: 0};
    $... -> #
    $@ -> (<{goblinAlive: <1>, elfAlive: <1>}> 0! <> 1!) !

    <{type: <'G'>, hitPoints: <1..>}>
      ..|@: {goblinAlive: 1};

    <{type: <'E'>, hitPoints: <1..>}>
      ..|@: {elfAlive: 1};
  end oneRaceStanding

def battle: $input -> Battle@{setCombatValues:basicCombatValues, isFightDecided:oneRaceStanding};
'$battle::run;
'-> !OUT::write

// part 2
templates victoryOrDeath
    @: {elfDied: 0, goblinAlive: 0};
    $... -> #
    $@ -> (<{elfDied: <1>}> -1 ! <{goblinAlive: <1>}> 0 ! <> 1 !) !

    <{type: <'G'>, hitPoints: <1..>}>
      ..|@: {goblinAlive: 1};

    <{type: <'E'>, hitPoints: <..0>}>
      ..|@: {elfDied: 1};
end victoryOrDeath

  templates tweakedCombatValues@{elfAttack:}
    <{type: <'G'>}>
      {$..., attackValue: 3, hitPoints: 200} !

    <{type: <'E'>}>
      {$..., attackValue: $elfAttack, hitPoints: 200} !
  end tweakedCombatValues

// should be source
templates part2
  @: { elfAttack: 3, result: -1 };
  $@ -> #

  <{result: <..~0>}>
    ..|@: { elfAttack: $@.elfAttack + 1 };
    def battle: $input -> Battle@{setCombatValues:tweakedCombatValues@{elfAttack: $@.elfAttack}, isFightDecided:victoryOrDeath};
    ..|@: { result: $battle::run};
    $@ -> #

  <{result: <0..>}>
    $@ -> !OUT::write
end part2

0 -> part2 -> !OUT::write
