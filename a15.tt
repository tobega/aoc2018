grammar cave
  #{ beings: [] }: { grid: <grid>, beings: $cave.beings }

  grid#{ row: 1, col: 1 }: [ <row>+ ]

  row: [ <square>+ ] (<'\n'>) ({ row: $grid.row + 1, col: 1 } -> $grid)

  square: { type: <<rock>|<cavern>>, row: $grid.row, col: $grid.col } ({col: $grid.col + 1} -> $grid)

// Do we have enums?
  rock: (<'#'>) 'rock'

  cavern: ({ code: <'[.GE]'>} -> $cavern) 'cavern' <occupant>?

  occupant: (<<gnome>|<elf>>) occupant: $occupant.type ({ type: $occupant.type, row: $grid.row, col: $grid.col} -> $cave.beings)

// Do we have object references? Or match-selection from arrays?
  gnome: ($cavern.code ?<'G'>) ({type: 'gnome'} -> $occupant)

  elf: ($cavern.code ?<'E'>) ({type: 'elf'} -> $occupant)
end cave

stereotype position <{row:<number>, col:<number>}>
stereotype square <position+{type: <'rock'|'cavern'>, occupant:<void|'gnome'|'elf'>}
stereotype being <position+{type:<'gnome'|'elf'>, attackValue: <number>, hitPoints: <number>}>

templates enemy
  $it ?<'elf'>('gnome') ?<'gnome'>('elf'))
end enemy

templates<[2]<position>> bestPosition
  <[] ?($it(1).row <$it(2).row!..>)>
    1

  <[] ?($it(1).row <..!$it(2).row>)>
    -1

  <[] ?($it(1).col <$it(2).col!..>}>}>
    1

  <*>
    -1
end bestPosition

processor Battleground
  mut grid<[*,*]<square>>

  templates<position> neighbours
    [ $grid($it.row, [$it.col-1, $it.col+1])... ,
      $grid([$it.row-1, $it.row+1], $it.col)... ]
  end neighbours

  templates<{row:, col:}> inRange(enemy <'gnome'|'elf'>)
    false -> $inRange
    $it -> neighbours -> $templates
    $inRange

    <{occupant: <$enemy>}> // Specifically, void never matches unless explicitly specified
      true -> $inRange // Or maybe something like exit or return?
  end inRange

  templates<[<square>]> bestSquareInRange(enemy <'gnome'|'elf'>)
    $it... -> $templates
    $bestSquareInRange

    <?($it -> inRange($enemy))>
      $let s = $it
      [$it, $bestSquareInRange] -> bestPosition -> (<-1> $s -> $bestSquareInRange)
  end bestSquareInRange

  stereotype direction <'up'|'left'|'right'|'down'>

  templates moveEntry(firstMove <direction>)
    <{type: 'cavern', occupant: void}>
      { key: $it, value: $firstMove }
  end moveEntry

  templates<{key: <square>, value: <direction>}> nextMoves
    $it.value -> $nextMoves
    // figure out rules for list-indices, may have to send through flatten
    $grid($it.key.row, [$it.key.col-1, $it.key.col+1])... -> moveEntry($it.value)
    $grid([$it.key.row-1, $it.row+1], $it.col)... -> moveEntry($it.value)
  end nextMoves

  templates<{a:<direction>, b:<direction>}> prioritizedDirection
    <{*:'up'}>
      'up'

    <{*:'left'}>
      'left'

    <{*:'right'}>
      'right'

    <*:'down'>
      'down'
  end prioritizedDirection

  source findDirectionToMove(combattant: <being>)
    {visited: ($grid($combattant.row, $combattant.col) -> <Set>.new),
        atDistance: <Map>.new
    } -> $findDirectionToMove
    $grid($combattant.row - 1, $combattant.col) -> moveEntry('up') -> $findDirectionToMove.atDistance.put
    $grid($combattant.row, $combattant.col - 1) -> moveEntry('left') -> $findDirectionToMove.atDistance.put
    $grid($combattant.row, $combattant.col + 1) -> moveEntry('right') -> $findDirectionToMove.atDistance.put
    $grid($combattant.row + 1, $combattant.col) -> moveEntry('down') -> $findDirectionToMove.atDistance.put
    $findDirectionToMove -> $templates

    <{atDistance: <=target($it.keys -> bestSquareInRange($combattant.type -> enemy))<square>>}>
      $target -> $it.atDistance.get

    <{atDistance: <?($it.isEmpty)>}>
      void

    <*>
      $let nextDistance = <Map>.new
      $findDirectionToMove.atDistance.keys -> $findDirectionToMove.visited.addAll
      $findDirectionToMove.atDistance.entries... -> nextMoves -> <?!($it.key -> findDirectionToMove.visited.contains)>
        -> { key: $it.key,
             value: ({a: $it.value, b: ($it.square -> $nextDistance.get)} -> prioritizedDirection)
           } -> $nextDistance.put // check-then-act race here, should we have an update method on Map? Or do this by 'fold'?
      {atDistance: $nextDistance} -> $findDirectionToMove
      $findDirectionToMove -> $templates
  end findDirectionToMove

  templates<being> maybeMove <being>
    $it -> $maybeMove
    $it -> inRange ?<false> (findDirectionToMove($maybeMove) -> $templates)
    $maybeMove

    <'up'>
      {dr:-1, dc:0} -> $templates

    <'left'>
      {dr:0, dc:-1} -> $templates

    <'right'>
      {dr:0, dc:1} -> $templates

    <'down'>
      {dr:1, dc:0} -> $templates

    <{dr:,dc:}>
      {occupant:void} -> $grid($combattant.row, $combattant.col)
      {occupant: $combattant.type} -> $grid($combattant.row + $it.dr, $combattant.col + $it.dc)
      $grid($combattant.row + $it.dr, $combattant.col + $it.dc) -> $maybeMove
  end maybeMove
end Battleground

templates copy
  <[*]>
    [ $it... -> $templates ]

  <{}>
    { $it... -> $templates }

  <*:<*>>
    $it.key: ($it.value -> $templates)

  <*>
    $it
end copy

processor Battle
  mut battleground <Battleground>
  mut beings [<being>]

  templates setCombatValues
    {attackValue: 3, hitPoints: 200} -> $it
    $it
  end setCombatValues

  templates stillFighting
    {elfAlive: false, gnomeAlive: false} -> $stillFighting
    $it... -> $templates
    $stillFighting.elfAlive && $stillFighting.gnomeAlive

    <{type: 'gnome', hitPoints: <1..>}>
      {gnomeAlive: true} -> $stillFighting

    <{type: 'elf', hitPoints: <1..>}>
      {elfAlive: true} -> $stillFighting
  end stillFighting

  sink<position> strike(attack <number>)
    $let pos = $it
    $let index = $beings -> [i](<$pos> $i)
    ($beings($index).hitPoints - $attack) -> $beings($index)
  end strike

  sink takeTurn
    $beings($it) -> battleground.maybeMove -> $beings($it)
    $beings($it) -> battleground.neighbours -> filter(inRange($beings($it).type -> enemy))
      -> sort(bestPosition) -> strike($beings($it).attackValue)
  end takeTurn

  source run
    [ $beings... -> setCombatValues ] -> $beings
    {round: -1, stillFighting: true} -> $run
    $run -> $templates

    <?($it.stillFighting)>
      {round: $run.round + 1} -> $run
      1..$beings.* -> (<?($beings($it) <{hitPoints: <1..>}>)> $it)
        -> sort(<> $beings([$it]) -> bestPosition) -> takeTurn
      { stillFighting: ($beings -> stillFighting)} -> $run
      $run -> $templates

    <>
      [ $beings... -> (<{hitPoints: <1..>}> $it) ] -> fold(0, <> $it.result + $it.item.hitPoints) -> (<> $it * $run.round)
  end run
end Battle

// part 1
let data = stdin -> cave
// How do we do new?
let battle = <Battle>.new(<Battleground.new($data.grid), $data.beings)
battle.run -> stdout
