def input: [ stdin -> [ $it... ] ]

templates flatten
  [ $it -> # ] !
  <[]> $it... -> #
  <> $it !
end flatten

templates bestPosition
  <[] ?($it(1).row <$it(2).row~..>)>
    1 !

  <[] ?($it(1).row <..~$it(2).row>)>
    -1 !

  <[] ?($it(1).col <$it(2).col~..>)>
    1 !

  <>
    -1 !
end bestPosition

templates first@{comp:}
  $it(1) -> @
  $it(2..-1)... -> #
  $@!
  <?([$it, $@] -> comp <..~0>)> $it -> @
end first

templates sort@{comp:}
  [] -> @
  $it -> #
  <[](2..)>
    def pivot: $it(1)
    [ [ $it(2..-1)... -> (
      <?([$it, $pivot] -> $comp <..0>)>
        $it !
      <>
        $it -> ...@sort
     )] -> sort@{comp:comp}..., $pivot, $@ -> sort@{comp:comp}... ] !
   <>
     $it !
end sort

processor Battleground
  $it -> [i,j]({ contains: $it, row: $i, col: $j } !) -> @

  templates neighbours
    $@Battleground($it.row; [$it.col-1, $it.col+1])... !
    $@Battleground([$it.row-1, $it.row+1]; $it.col)... !
  end neighbours

  templates inRange@{target:}
    0 -> @
    $it -> neighbours
      -> (<{contains:<$target>}> 1 -> @inRange) -> void
    $@ !
  end inRange

  templates maybeMove@{target:}
    $it -> @
    $it -> inRange@{target:$target} -> (<0> $it !) -> findDirectionToMove -> #

    <'up'>
      {dr:-1, dc:0} -> #

    <'left'>
      {dr:0, dc:-1} -> #

    <'right'>
      {dr:0, dc:1} -> #

    <'down'>
      {dr:1, dc:0} -> #

    <{dr:<>,dc:<>}>
      def move: $it
      {contains:'.'} -> ...@Battleground($@.row; $@.col)
      {contains: $@.type} -> ...@Battleground($@.row + $move.dr; $@.col + $move.dc)
      $@Battleground($@.row + $move.dr; $@.col + $move.dc) !
  end maybeMove
end Battleground

processor Battle@{setCombatValues:, isFightDecided:}
  { battleground: $it -> Battleground,
    beings: [ $it -> [i,j](<'G'|'E'> { type: $it, row: $i, col: $j } !)
      -> flatten... -> setCombatValues] } -> @

  templates beingIndex
    def col:$it.col
    def row: $it.row
    $@Battle.beings -> [i](<{col:<$col>, row:<$row>}> $i !) -> $it(1) !
  end beingIndex

  // should be sink
  templates strike@{damage:}
    def pos: $it
    def index: $it -> beingIndex
    ($@Battle.beings($index).hitPoints - $damage) -> @Battle.beings($index).hitPoints
  end strike

  templates enemyType
    <'G'> 'E' !
    <'E'> 'G' !
  end enemyType

  templates adjacentEnemy@{me:}
    def enemy: $me -> enemyType
    $it -> $@Battle.battleground::neighbours
      -> (<{contains:<$enemy>}> $it !) !
  end adjacentEnemy

  // should be sink
  templates takeTurn
    def who: $it -> beingIndex
    def enemy: $it.type -> enemyType
    $@Battle.beings($who) -> $@Battle.battleground::maybeMove@{target:$enemy}
      -> ...@Battle.beings($who)
    [ $@Battle.beings($who) -> adjacentEnemy@{me: $@Battle.beings($who).type}
    ] -> (<[](1..)> $it!) -> first@{comp: bestPosition} -> strike@{damage: $@Battle.beings($who).attackValue}
      -> void
  end takeTurn

  // should be source
  templates run
    {round: -1, stillFighting: 0} -> @
    $@ -> #

    <{stillFighting: <0>}>
      $@.round + 1 -> @.round
      $@Battle.beings -> sort@{comp: bestPosition}...
        -> (<{hitPoints: <1..>}> $it !)
        -> takeTurn -> void
      $@Battle.beings -> isFightDecided -> @.stillFighting
      $@ -> #

    <>
      [ $@Battle.beings... -> (<{hitPoints: <1..>}> $it.hitPoints !) ] -> sum -> $it * $@.round !
  end run
end Battle

// part 1

  templates basicCombatValues
    {$it..., attackValue: 3, hitPoints: 200} !
  end basicCombatValues

  templates oneRaceStanding
    {elfAlive: 0, goblinAlive: 0} -> @
    $it... -> #
    $@ -> (<{goblinAlive: <1>, elfAlive: <1>}> 0! <> 1!) !

    <{type: <'G'>, hitPoints: <1..>}>
      {goblinAlive: 1} -> ...@

    <{type: <'E'>, hitPoints: <1..>}>
      {elfAlive: 1} -> ...@
  end oneRaceStanding

def battle: $input -> Battle@{setCombatValues:basicCombatValues, isFightDecided:oneRaceStanding}
$battle::run -> stdout
