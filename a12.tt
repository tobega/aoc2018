grammar plants
  data: ('initial state: ') { state: <STATE>, rules: <rules> }

  STATE: [ <'[.#]+'>.chars[i] -> f{}($it?<'#'>($i)) ]

  rules: [ [ <rule>+ ] -> sort{ comp: f{}($it.a.num - $it.b.num)}... -> f{}($it.result) ]

  rule: { num: <RULE_NUM>, (' => ') result: <IS_PLANT> }

  RULE_NUM: <'[.#]+'>.chars -> encodeRule

  IS_PLANT: '[.#]' -> ?=<'#'>
end plants

templates encodeRule
  {rule: 0}
  $it... -> $templates
  $encodeRule.rule

   <'#'>
     { rule: ($encodeRule.rule << 1) + 1 } -> $encodeRule

   <'.'>
     { rule: $encodeRule.rule << 1 } -> $encodeRule
end encodeRule

templates<[*]> reduce(f: <templates<{a:, b:}>>)
  { result: $it(1) } -> $reduce
  $it(2..)... -> $templates
  $reduce.sum

  <*>
    { result: ({a: $reduce.result, b: $it} -> $f) } -> $reduce
end reduce

processor Game
  mut state: <[*]<number>>
  rules: <[32]<bool>>

  source evolve<void>
    templates checkAndShift
      { newState: $rules($it.locale) ?<true> ($it.pos -> $it.newState) ?<*> ($it.newState),
              pos: $it.pos + 1, locale: (($it.locale << 1) & 0x1f) } -> $it
    end checkAndShift
    { pos: state(1) - 2, i: 1, locale: 0, newState: [] } -> $templates

    <{pos: <$state($it.i)-2>}>
      { locale: $it.locale | 1, i: $it.i + 1 } -> $it -> $templates

    <{i: <..$state.*>}>
      $it -> checkAndShift -> $templates

    <{locale: <0!..>}>
      $it -> checkAndShift -> $templates

    <*>
      {state: $it.newstate} -> $Game
  end evolve

   source potSum
     $state -> reduce(<{a: <number>, b: <number>}> $it.a + $it.b)
   end potSum

end Game

grammar<string> arglist
  args: { <generations>? file: <'.+'> }

  generations: generations: (<'--generations'|'-g'>) (<'\\d+'> -> <number>.parse)
end args

main(args: <[*]<string>>)
  let input = args -> arglist.args
  let game = input.file -> readfile -> plants.data -> <Game>.new
  [1..input.generations](game.evolve)
  game.potSum -> stdout
end main