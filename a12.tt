composer plants
  (<'initial state: '>) { state: <~WS> (<WS>*), rules: <rules> }

  rule rules: [ <rule>+ ]

  rule rule: { pattern: <'[.#]+'> (<' => '>), result: <'[.#]'> } (<WS>*)
end plants

templates encodeRule
  @: 0;
  $... -> #
  $@ !

   <'#'>
     @: ($@ * 2) + 1;

   <'.'>
     @: $@ * 2;
end encodeRule

templates reduce@{f:}
  @: $(1);
  $(2..-1)... -> @: [ $@, $] -> f;
  $@!
end reduce

processor Plantation
  @: $;

  templates debug
    $@Plantation.state !
  end debug

  templates evolve // should be sink (or really sink&source)
    templates checkAndShift
      <{locale: <0>}>
        { $..., pos: $.pos + 1 } !
      <>
        def prev: $;
        { $prev..., newState: $@Plantation.rules($prev.locale) -> (<'#'> [$prev.newState..., $prev.pos] ! <> $prev.newState !),
              pos: $prev.pos + 1, locale: (($prev.locale * 2) mod 32) } !
    end checkAndShift

    { pos: $@Plantation.state(1) - 2, i: 1, locale: 0, newState: [] } -> #

    <{i: <..$@Plantation.state::length>}?($.pos <$@Plantation.state($.i)-2>)>
      def prev: $;
      { $prev..., locale: $.locale + 1, i: $.i + 1 } -> #

    <{i: <..$@Plantation.state::length>}>
      $ -> checkAndShift -> #

    <{locale: <0~..>}>
      $ -> checkAndShift -> #

    <>
      ..|@Plantation: {state: $.newState};
  end evolve

  templates potSum // should be source
      templates sum
        $(1) + $(2) !
      end sum
    $@Plantation.state -> reduce@{f:sum} !
  end potSum

end Plantation

templates makeIndexed
  @: [1..$::length -> '.'];
  $... -> #
  $@!
  <{rule: <1..>}>
    @($.rule): $.result;
end makeIndexed

def startState: '$IN::lines -> ($! ' '!);' -> plants -> { state: [$.state...] -> [i](<'#'> $i - 1 !),
  rules: [ $.rules... -> { rule: $.pattern -> encodeRule, result: $.result }] -> makeIndexed};

def part1: $startState -> Plantation;
1..20 -> $part1::evolve -> !VOID
$part1::potSum -> !OUT::write
