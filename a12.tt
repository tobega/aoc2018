composer plants
  (<'initial state: '>) { state: <~WS> (<WS>*), rules: <rules> }

  rules: [ <rule>+ ]

  rule: { pattern: <'[.#]+'> (<' => '>), result: <'[.#]'> } (<WS>*)
end plants

templates encodeRule
  0 -> @
  $it... -> #
  $@ !

   <'#'>
     ($@ * 2) + 1 -> @

   <'.'>
     $@ * 2 -> @
end encodeRule

templates reduce@{f:}
  $it(1) -> @
  $it(2..-1)... -> #
  $@!

  <>
    [ $@, $it] -> $f -> @
end reduce

processor Plantation
  $it -> @

  templates debug
    $@Plantation.state !
  end debug

  templates evolve // should be sink (or really sink&source)
    templates checkAndShift
      <{locale: <0>}>
        { $it..., pos: $it.pos + 1 } !
      <>
        def prev: $it
        { $prev..., newState: $@Plantation.rules($prev.locale) -> (<'#'> [$prev.newState..., $prev.pos] ! <> $prev.newState !),
              pos: $prev.pos + 1, locale: (($prev.locale * 2) mod 32) } !
    end checkAndShift

    { pos: $@Plantation.state(1) - 2, i: 1, locale: 0, newState: [] } -> #

    <{i: <..$@Plantation.state::length>}?($it.pos <$@Plantation.state($it.i)-2>)>
      def prev: $it
      { $prev..., locale: $it.locale + 1, i: $it.i + 1 } -> #

    <{i: <..$@Plantation.state::length>}>
      $it -> checkAndShift -> #

    <{locale: <0~..>}>
      $it -> checkAndShift -> #

    <>
      {state: $it.newState} -> ...@Plantation
  end evolve

  templates potSum // should be source
      templates sum
        $it(1) + $it(2) !
      end sum
    $@Plantation.state -> reduce@{f:sum} !
  end potSum

end Plantation

templates makeIndexed
  [1..$it::length -> '.'] -> @
  $it... -> #
  $@!
  <{rule: <1..>}>
    def rule: $it.rule
    $it.result -> @($rule)
end makeIndexed

def startState: '$(stdin -> ($it! ' '!))' -> plants -> { state: [$it.state...] -> [i](<'#'> $i - 1 !),
  rules: [ $it.rules... -> { rule: $it.pattern -> encodeRule, result: $it.result }] -> makeIndexed}

def part1: $startState -> Plantation
1..20 -> $part1::evolve -> void
$part1::potSum -> stdout
