grammar log

[ <record>+ ]

record: { time: (<'\['>) <ISO_DATE_TIME> (<'] '>), note: <TO_LINE_END> }

ISO_DATE_TIME: <'\d\d\d\d-\d\d-\d\d \d\d:\d\d(:\d\d)?'> -> <DateTime>.parse

TO_LINE_END: <'[^\n]'*> (<'\n'>)

end log

// removes the second array level, i.e. [ [1,2], [3, [4,5]], 6] becomes [1,2,3,[4,5],6]
templates concat
  [ $it... -> $templates ]

  <[]>
    $it...

  <*>
    $it
end concat

templates bubblesort(comp <templates<[](2)>:<number>>)
  $let templates dragHighest
      [ $it -> $templates ]
      <[](..1)>
        $it...
      <[](2)?($it([1,2]) -> comp) <1>)>
        $it([2,1])...

      <?($it([1,2]) -> comp) <1>)>
        $it(2)
        [ $it(1), $it(3..) ] -> $templates
      <>
        $it(1)
        $it(2..) -> $templates
  end dragHighest
  { toSort: $it, done: [] } -> $templates
  <{ toSort: <[](..1)> }>
    [ $it.toSort..., $it.done... ]
  <>
    $let partial = $it.toSort -> dragHighest
    { toSort: $partial(1..-2), done: [ $partial(-1), $it.done... ] } -> $templates
end bubblesort

grammar<{*}> shiftNaps
[ <shift>+ ]

shift: { guard: (<{note: <'Guard #(?<g>\d+).*'>}>) $g, naps: [ <nap>+ ] }

nap: { sleep: (<{time: ms=<*>, note:'falls asleep'}>) $ms.minute,
       wake: (<{time: mw=<*>, note:'wakes up'}>) $mw.minute }
end shiftNaps

templates timeOrder
  <?($it(1).time <..!$it(2).time>)> -1
  <?($it(1).time <$it(2).time>)> 0
  <> 1
end timeOrder

let shifts = 'a4.txt' -> readfile -> log.file -> bubblesort(timeOrder) -> ... -> shiftNaps

interface Aggregator<T> <{ aggregate: <sink<T>>, result: <source<T>> }>

templates summarize(groupings <[*:]>, aggregates <[*: <<Aggregator>>]>)
  Map.new -> $summarize
  $it... -> $templates
  $summarize.entries -> { $it.key -> [i]($groupings($i): $it) -> $it...,
    $it.value... }

  <?($it.$groupings -> $summarize.contains)>
    let aggregators = $it -> [k:$groupings]($it.$k) -> []($summarize.get)
    $it -> [a:$aggregators]($it.($a.key) -> $a.value.aggregate)

  <>
    {key: ($it -> [k:$groupings]($it.$k)), value: [a:$aggregates]($a.key: $a.value.new)

end summarize

processor Sum <Aggregator<number>>
  sum <number> = 0
  sink aggregate
    $sum + $it -> $sum
  end aggregate

  source result
    $sum
  end result
end Sum

templates sleepiestMinute
  [i:0..59](0) -> $sleepiestMinute
  $it.naps -> $templates
  $let sleepyIndex = 1..60 -> reduce(max(i=<> $sleepiestMinute($i)) // Compare by transformed index.
  { sleepiestMinute: $sleepyIndex - 1, timesSlept: $sleepiestMinute($sleepyIndex) }

  <>
    $it.wake..$it.sleep -> (min=<> $sleepiestMinute($min + 1) + 1 -> $sleepiestMinute($min + 1))
end sleepiestMinute

processor Collate <Aggregator<[]>>
  list = []
  sink aggregate
    $it... -> $list
  end aggregate

  source result
    $list
  end result
end Collate

// part 1
let sleepiestGuard = $shifts -> {guard: $it.guard, asleep: ($it.naps -> []($it.wake - $it.sleep) -> reduce<+>)}
  -> summarize([(guard:)], [(asleep: <Sum>)]) -> reduce(max(asleep:)) // Compare by asleep:.
  -> $it.guard

[ $shifts... -> (<{guard: $sleepiestGuard}> $it) ] -> summarize([(guard:)], [(naps: <Collate>)]) ->
   $it(1) -> sleepiestMinute -> $it.sleepiestMinute * $sleepiestGuard.guard -> stdout

// part 2
$shifts -> summarize([(guard:), [(naps: <Collate>)]) -> [ $it... -> { guard: $it.guard, sleepPattern: $it -> sleepiestMinute} ]
  -> reduce(max(sleepPattern.timesSlept:)) -> $it.guard * $it.sleepPattern.sleepiestMinute -> stdout
