grammar log

[ <record>+ ]

record: { time: (<'\['>) <ISO_DATE_TIME> (<'] '>), note: <TO_LINE_END> }

ISO_DATE_TIME: <'\d\d\d\d-\d\d-\d\d \d\d:\d\d(:\d\d)?'> -> <DateTime>.parse

TO_LINE_END: <'[^\n]'*> (<'\n'>)

end log

// removes the second array level, i.e. [ [1,2], [3, [4,5]], 6] becomes [1,2,3,[4,5],6]
templates concat
  [ $it... -> $templates ]

  <[]>
    $it...

  <*>
    $it
end concat

templates bubblesort(comp <templates<[](2)>:<number>>)
  $let templates dragHighest
    { elem: $it(1) } -> $dragHighest
    [ $it(2..)... -> $templates, $dragHighest.elem ]

    <*>
        $it -> (<?(([$dragHighest.elem, $it] -> $comp) <..0>)> $it
           <*> $dragHighest.elem ({elem: $it} -> dragHighest))
  end dragHighest
  { arr: $it } -> $bubblesort
// How to represent the length property? .* or special |array| or just .length?
  1..($it.*-2) -> $templates
  $bubblesort.arr

  <number>
    { arr: ([ ($arr(1..-$it) -> dragHighest), $arr(-$it!..) ] -> concat) } -> $bubblesort
end bubblesort

grammar<{*}> shiftNaps
[ <shift>+ ]

shift: { guard: (<{note: <'Guard #(?<g>\d+).*'>}>) $g, naps: [ <nap>+ ] }

nap: { sleep: (<{time: ms=<*>, note:'falls asleep'}>) $ms.minute,
       wake: (<{time: mw=<*>, note:'wakes up'}>) $mw.minute }
end shiftNaps

templates timeOrder
  <?($it(1).time <..!$it(2).time>)> -1
  <?($it(1).time <$it(2).time>)> 0
  <> 1
end timeOrder

let shifts = 'a4.txt' -> readfile -> log.file -> bubblesort(timeOrder) -> ... -> shiftNaps

interface Aggregator <{ aggregate: <sink<*>>, result: <source<*>> }>

templates summarize(groupings <[*:]>, aggregates <[*: <<Aggregator>>]>)
  Map.new -> $summarize
  $it... -> $templates
  $summarize.entries -> { $it.key -> [i]($groupings($i): $it) -> ...,
    $it.value... }

  <?($it.$groupings -> $summarize.contains)>
    let aggregators = $it.$groupings -> $summarize.get
    $it -> [a:$aggregators]($it.($a.key) -> $a.value.aggregate)

  <>
    {key: $it.$groupings, value: [a:$aggregates]($a.key: $a.value.new)

end summarize

processor Sum <Aggregator>
  sum <number> = 0
  sink aggregate
    $sum + $it -> $sum
  end aggregate

  source result
    $sum
  end result
end Sum

let sleepiestGuard = $shifts -> {guard: $it.guard, asleep: ($it.naps.wake - $it.naps.sleep -> reduce<+>)
  -> summarize([guard], [asleep: <Sum>]) -> reduce(max(asleep:)) // Not sure how to get this to work
  -> .guard

templates sleepiestMinute
  [i:0..59](0) -> $sleepiestMinute
  $it.naps -> concat -> $templates
  $sleepiestMinute -> reduce(max([i]) // Not sure how to get this to work

  <>
    $it.wake..$it.sleep -> (min=<> $sleepiestMinute($min + 1) + 1 -> $sleepiestMinute($min + 1))
end sleepiestMinute

$shifts -> (<{guard: $sleepiestGuard}> $it) -> sleepiestMinute * $sleepiestGuard.guard