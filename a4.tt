grammar log

[ <record>+ ]

record: { time: (<'\['>) <ISO_DATE_TIME> (<'] '>), note: <TO_LINE_END> }

ISO_DATE_TIME: <'\d\d\d\d-\d\d-\d\d \d\d:\d\d(:\d\d)?'> -> <DateTime>.parse

TO_LINE_END: <'[^\n]'*> (<'\n'>)

end log

// removes the second array level, i.e. [ [1,2], [3, [4,5]], 6] becomes [1,2,3,[4,5],6]
templates concat
  [ $it... -> $templates ]

  <[..]>
    $it...

  <*>
    $it
end concat

templates bubblesort
  $let templates dragHighest
    { elem: $it(1) } -> $dragHighest
    [ $it(2..)... -> $templates, $dragHighest.elem ]

    <*>
        $it ?<..$dragHighest.elem>( $it ) ?<*>( $dragHighest.elem ({elem: $it} -> dragHighest))
  end dragHighest
  { arr: $it } -> $bubblesort
// How to represent the length property? .* or special |array| or just .length?
  1..($it.*-2) -> $templates
  $bubblesort.arr

  <number>
    { arr: ([ ($arr(1..-$it) -> dragHighest), $arr(-$it!..) ] -> concat) } -> $bubblesort
end bubblesort

grammar<{*}> collate

shifts: [ <shift>+ ]

// Should string matchers always be regex? Or do we need special notation for regex?
shift: { guard: (<{note:'Guard #(\d+).*'(g=$1)}>)($g), naps: [ <nap>+ ] }

nap: { sleep: (<{time: ms=<*>, note:'falls asleep'}>) #($ms.minute),
       wake: (<{time: mw=<*>, note:'wakes up'}>) #($mw.minute) }
end collate

let shifts = 'a4.txt' -> readfile -> log.file -> (bubblesort)... -> collate.shifts


