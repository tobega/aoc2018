composer step
  { dep: (<'Step '>) <'.'>, (<' must be finished before step '>) step: <'.'> (<' can begin.'>) }
end step

def deps: [ $IN::lines -> step ];

templates in@{values:}
  def what: $;
  @: 0;
  $values... -> #
  $@ !
  <$what>
    @: 1;
end in

templates reduce@{operator:}
  @: $(1);
  $(2..-1)... -> @reduce: [$@reduce, $] -> operator;
  $@ !
end reduce

templates min
  <?($(1)<..$(2)>)> $(1) !
  <> $(2) !
end min

// part 1
templates topological
 def waiting: [ $... -> $.step ];
 { unresolved: $,
   ready: [ $... -> $.dep -> (<?($ -> in@{values: $waiting} <0>)> $ !) ] } -> #
 <{ready: <[](1..)>}>
   def current: $;
   def next: $current.ready -> reduce@{operator:min};
   $next !
   def unresolved: [ $current.unresolved... -> (<?($.dep <~$next>)> $! ) ];
   def waiting: [ $unresolved... -> $.step ];
   { unresolved: $unresolved,
     ready: [ $current.ready... -> (<~$next> $ !),
       $current.unresolved... -> (<?($.dep <$next>)> $! ) -> $.step -> (<?($ -> in@{values: $waiting} <0>)> $ !)]
   } -> #
end topological

$deps -> topological -> !OUT::write
'
' -> !OUT::write

// part 2
def tasks: ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'...];
templates taskIndex
  def value: $;
  $tasks -> [i](<$value> $i !)... !
end taskIndex

templates minByTime
  <?($(1).time<..$(2).time>)> $(1) !
  <> $(2) !
end minByTime

templates multi@{workers:, delay:}
 @: 0;
 def waiting: [ $... -> $.step ];
 { unresolved: $,
   ready: [ $... -> $.dep -> (<?($ -> in@{values: $waiting} <0>)> $ !) ],
   workers: []} -> #
 $@ !

 <{workers: <[](..$workers-1)>, ready: <[](1..)>}>
  def current: $;
  def next: $current.ready -> reduce@{operator:min};
  { workers: [ $current.workers..., {task: $next, time: $delay + ($next -> taskIndex) }],
    ready: [$current.ready... -> (<~$next> $!)],
    unresolved: $current.unresolved } -> #

 <{workers: <[](1..)>}>
   def mintime: $.workers -> reduce@{operator:minByTime} -> $.time;
   @: $mintime + $@;
   def current: $;
   def workers: [ $.workers... ->  { task: $.task, time: $.time - $mintime } ];
   def done: [$workers...  -> (<?($.time <0>)> $ !) -> $.task];
   def unresolved: [ $current.unresolved... -> (<?($.dep -> in@{values:$done} <0>)> $! ) ];
   def waiting: [ $unresolved... -> $.step ];
   { unresolved: $unresolved,
     ready: [ $current.ready... -> (<?($ -> in@{values:$done} <0>)> $ !),
       $current.unresolved... -> (<?($.dep -> in@{values:$done} <1>)> $! ) -> $.step -> (<?($ -> in@{values: $waiting} <0>)> $ !)],
     workers: [ $workers... -> (<?($.time <1..>)> $ !)]
   } -> #
end multi

$deps -> multi@{workers: 5, delay: 60} -> !OUT::write

